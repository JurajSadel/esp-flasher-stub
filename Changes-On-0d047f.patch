diff --git a/rustfmt.toml b/rustfmt.toml
new file mode 100644
index 0000000..0a9902d
--- /dev/null
+++ b/rustfmt.toml
@@ -0,0 +1,9 @@
+# Comments
+format_code_in_doc_comments = true
+normalize_comments          = true
+wrap_comments               = true
+
+# Imports
+group_imports       = "StdExternalCrate"
+imports_granularity = "Crate"
+imports_layout      = "HorizontalVertical"
diff --git a/src/commands.rs b/src/commands.rs
index f2c3ebe..fa516c3 100644
--- a/src/commands.rs
+++ b/src/commands.rs
@@ -1,8 +1,8 @@
-#[allow(unused)]
-#[repr(u8)]
-#[derive(PartialEq, Eq, Copy, Clone, Debug)]
+// Size of sesponse without data reference
+pub const RESPONSE_SIZE: usize = 10;
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub enum Error {
-    None = 0,
     BadDataLen = 0xC0,
     BadDataChecksum = 0xC1,
     BadBlocksize = 0xC2,
@@ -22,9 +22,8 @@ pub enum Error {
     Err0x35 = 0x35,
 }
 
-#[allow(unused)]
-#[derive(PartialEq, Eq, Copy, Clone, Debug)]
-pub enum Code {
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum CommandCode {
     FlashBegin = 0x02,
     FlashData = 0x03,
     FlashEnd = 0x04,
@@ -49,67 +48,75 @@ pub enum Code {
     FlashEncryptedData = 0xD4,
 }
 
-#[derive(PartialEq, Copy, Clone, Debug)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
-pub struct Base {
-    direction: Direction,
-    pub code: Code,
+pub struct CommandBase {
+    pub direction: u8,
+    pub code: CommandCode,
     pub size: u16,
     pub checksum: u32,
 }
 
-#[derive(PartialEq, Copy, Clone, Debug)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct Sync {
-    pub base: Base,
+    pub base: CommandBase,
     pub payload: [u8; 36],
 }
 
-#[derive(PartialEq, Copy, Clone, Debug)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct Begin {
-    pub base: Base,
+    pub base: CommandBase,
     pub total_size: u32,
     pub packt_count: u32,
     pub packet_size: u32,
     pub offset: u32,
 }
 
-#[derive(PartialEq, Copy, Clone, Debug)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct Data {
-    pub base: Base,
+    pub base: CommandBase,
     pub size: u32,
     pub sequence_num: u32,
     pub reserved: [u32; 2],
 }
 
-#[derive(PartialEq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
-pub struct End {
-    pub base: Base,
+pub struct EndFlash {
+    pub base: CommandBase,
     pub run_user_code: u32,
 }
 
-#[derive(PartialEq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+#[repr(C, packed(1))]
+pub struct MemEnd {
+    pub base: CommandBase,
+    pub stay_in_stub: u32,
+    pub entrypoint: fn(),
+}
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct WriteReg {
-    pub base: Base,
+    pub base: CommandBase,
     pub address: u32,
     pub value: u32,
     pub mask: u32,
     pub delay_us: u32,
 }
 
-#[derive(PartialEq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct ReadReg {
-    pub base: Base,
+    pub base: CommandBase,
     pub address: u32,
 }
 
 // Possibly move to other module
-#[derive(PartialEq, Eq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct SpiParams {
     pub id: u32,
@@ -120,40 +127,40 @@ pub struct SpiParams {
     pub status_mask: u32,
 }
 
-#[derive(PartialEq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct SpiSetParams {
-    pub base: Base,
+    pub base: CommandBase,
     pub params: SpiParams,
 }
 
-#[derive(PartialEq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct ChangeBaudrate {
-    pub base: Base,
+    pub base: CommandBase,
     pub new: u32,
     pub old: u32,
 }
 
-#[derive(PartialEq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct SpiFlashMd5 {
-    pub base: Base,
+    pub base: CommandBase,
     pub address: u32,
     pub size: u32,
     pub reserved: [u32; 2],
 }
 
-#[derive(PartialEq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct EraseRegion {
-    pub base: Base,
+    pub base: CommandBase,
     pub address: u32,
     pub size: u32,
 }
 
 // Possibly move to other module
-#[derive(PartialEq, Eq, Copy, Clone, Debug)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct ReadFlashParams {
     pub address: u32,
@@ -162,52 +169,34 @@ pub struct ReadFlashParams {
     pub max_inflight: u32,
 }
 
-#[derive(PartialEq, Copy, Clone, Debug)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct ReadFlash {
-    pub base: Base,
+    pub base: CommandBase,
     pub params: ReadFlashParams,
 }
 
-#[allow(unused)]
-#[repr(u8)]
-#[derive(PartialEq, Copy, Clone, Debug)]
-enum Direction {
-    In,
-    Out,
-}
-
-#[repr(u8)]
-#[derive(PartialEq, Copy, Clone)]
-enum Status {
-    Success,
-    Failure,
-}
-
-#[derive(PartialEq, Copy, Clone)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[repr(C, packed(1))]
 pub struct Response<'a> {
-    direction: Direction,
-    command: Code,
-    size: u16,
-    value: u32,
-    status: Status,
-    error: Error,
+    pub direction: u8,
+    pub command: CommandCode,
+    pub size: u16,
+    pub value: u32,
+    pub status: u8,
+    pub error: u8,
     pub data: &'a [u8],
 }
 
-// Size of sesponse without data reference
-pub const RESPONSE_SIZE: usize = 10;
-
 impl<'a> Response<'a> {
-    pub fn new(cmd: Code) -> Self {
+    pub fn new(cmd: CommandCode) -> Self {
         Response {
-            direction: Direction::Out,
+            direction: 1,
             command: cmd,
             size: 2,
             value: 0,
-            status: Status::Success,
-            error: Error::None,
+            status: 0,
+            error: 0,
             data: &[],
         }
     }
@@ -216,14 +205,13 @@ impl<'a> Response<'a> {
         self.value = value;
     }
 
-    #[allow(unused)]
     pub fn data(&mut self, data: &'a [u8]) {
         self.size = 2 + data.len() as u16;
         self.data = data;
     }
 
     pub fn error(&mut self, error: Error) {
-        self.status = Status::Failure;
-        self.error = error;
+        self.status = 1;
+        self.error = error as u8;
     }
 }
diff --git a/src/main.rs b/src/main.rs
index 6f9bc0b..e5679b9 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,71 +1,56 @@
-#![cfg_attr(not(test), no_std)]
-#![cfg_attr(not(test), no_main)]
-
-use core::panic::PanicInfo;
-
-use esp32c3_hal::{
-    clock::ClockControl,
-    interrupt::{self, CpuInterrupt, InterruptKind, Priority},
-    pac,
-    prelude::SystemExt,
-    serial::{config::Config, Serial, TxRxPins},
-    Cpu,
-    IO,
+#![no_main]
+#![no_std]
+
+use esp_backtrace as _;
+use flasher_stub::{
+    hal::{
+        self,
+        clock::ClockControl,
+        pac,
+        prelude::*,
+        serial::{config::Config, TxRxPins},
+        Serial,
+        IO,
+    },
+    protocol::Stub,
+    targets,
 };
+#[cfg(target_arch = "riscv32")]
 use riscv_rt::entry;
+#[cfg(target_arch = "xtensa")]
+use xtensa_lx_rt::entry;
 
-use crate::{protocol::Stub, targets::esp32c3 as target};
-
-mod commands;
-mod dprint;
-mod miniz_types;
-mod protocol;
-mod serial_io;
-mod targets;
-
-const MSG_BUFFER_SIZE: usize = target::MAX_WRITE_BLOCK + 0x400;
+const MSG_BUFFER_SIZE: usize = targets::MAX_WRITE_BLOCK + 0x400;
 
 #[entry]
 fn main() -> ! {
     let peripherals = pac::Peripherals::take().unwrap();
+    #[cfg(any(target_arch = "riscv32"))]
     let system = peripherals.SYSTEM.split();
+    #[cfg(any(target_arch = "xtensa"))]
+    let system = peripherals.DPORT.split();
     let clocks = ClockControl::boot_defaults(system.clock_control).freeze();
 
-    // Init debug UART
     let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
     let pins = TxRxPins::new_tx_rx(
-        io.pins.gpio10.into_push_pull_output(),
+        io.pins.gpio18.into_push_pull_output(),
         io.pins.gpio9.into_floating_input(),
     );
-    let cfg = Config::default().baudrate(921600);
+
+    let cfg = Config::default().baudrate(921_600);
     let _ = Serial::new_with_config(peripherals.UART1, Some(cfg), Some(pins), &clocks);
 
-    // Init IO serial
     let mut serial = Serial::new(peripherals.UART0);
-    serial.set_rx_fifo_full_threshold(1);
-    serial.listen_rx_fifo_full();
 
-    interrupt::enable(pac::Interrupt::UART0, interrupt::Priority::Priority3).ok();
-    interrupt::set_kind(Cpu::ProCpu, CpuInterrupt::Interrupt3, InterruptKind::Level);
-    unsafe {
-        interrupt::set_priority(Cpu::ProCpu, CpuInterrupt::Interrupt3, Priority::Priority10);
-        riscv::interrupt::enable();
-    }
+    // Must be called after Serial::new, as it disables interrupts
+    serial_io::enable_uart0_rx_interrupt();
 
     let mut stub = Stub::new(&mut serial);
     stub.send_greeting();
 
-    target::init();
-
     let mut buffer: [u8; MSG_BUFFER_SIZE] = [0; MSG_BUFFER_SIZE];
     loop {
         let data = stub.read_command(&mut buffer);
         stub.process_command(data);
     }
 }
-
-#[panic_handler]
-fn panic(_info: &PanicInfo) -> ! {
-    dprintln!("Panic !!!");
-    loop {}
-}
diff --git a/src/protocol.rs b/src/protocol.rs
index 80a8d2d..b1ee51b 100644
--- a/src/protocol.rs
+++ b/src/protocol.rs
@@ -1,32 +1,20 @@
 use core::{cmp::min, mem::size_of, slice};
 
 use md5::{Digest, Md5};
-use slip::{read_packet, write_delimiter, write_packet, write_raw};
-use target::{
-    change_baudrate, delay_us, erase_flash, erase_region, flash_erase_block, flash_erase_sector,
-    get_security_info, read_register, soft_reset, spi_attach, spi_flash_read, spi_set_params,
-    spiflash_write, unlock_flash, write_encrypted, write_encrypted_disable, write_encrypted_enable,
-    write_register, FLASH_BLOCK_SIZE, FLASH_SECTOR_MASK,
-};
+use slip::*;
 
-#[cfg_attr(test, mockall_double::double)]
-use crate::targets::esp32c3 as target;
 use crate::{
-    commands::{self, Code, Error, Response, RESPONSE_SIZE},
-    dprintln,
-    miniz_types::{
-        tinfl_decompressor, TinflStatus, TINFL_FLAG_HAS_MORE_INPUT, TINFL_FLAG_PARSE_ZLIB_HEADER,
-    },
+    commands::{CommandCode::*, Error::*, *},
+    miniz_types::*,
+    targets::{EspCommon, FLASH_BLOCK_SIZE, FLASH_SECTOR_MASK},
 };
 
-const DATA_CMD_SIZE: usize = size_of::<commands::Data>();
-const CMD_BASE_SIZE: usize = size_of::<commands::Base>();
+const DATA_CMD_SIZE: usize = size_of::<DataCommand>();
+const CMD_BASE_SIZE: usize = size_of::<CommandBase>();
 
 const FLASH_SECTOR_SIZE: u32 = 4096;
 const MAX_WRITE_BLOCK: u32 = 0x4000;
 
-type FlashFunc = fn(addr: u32, data: *const u8, len: u32) -> Result<(), Error>;
-
 pub trait InputIO {
     fn recv(&mut self) -> u8;
     fn send(&mut self, data: &[u8]);
@@ -42,6 +30,10 @@ pub struct Stub<'a> {
     decompressor: tinfl_decompressor,
     last_error: Option<Error>,
     in_flash_mode: bool,
+    #[cfg(feature = "esp32c3")]
+    target: crate::targets::Esp32c3,
+    #[cfg(feature = "esp32")]
+    target: crate::targets::Esp32,
 }
 
 fn slice_to_struct<T: Sized + Copy>(slice: &[u8]) -> Result<T, Error> {
@@ -60,25 +52,9 @@ fn u32_from_slice(slice: &[u8], index: usize) -> u32 {
     u32::from_le_bytes(slice[index..index + 4].try_into().unwrap())
 }
 
-fn calculate_md5(mut address: u32, mut size: u32) -> Result<[u8; 16], Error> {
-    let mut buffer: [u8; FLASH_SECTOR_SIZE as usize] = [0; FLASH_SECTOR_SIZE as usize];
-    let mut hasher = Md5::new();
-
-    while size > 0 {
-        let to_read = min(size, FLASH_SECTOR_SIZE);
-        target::spi_flash_read(address, &mut buffer)?;
-        hasher.update(&buffer[0..to_read as usize]);
-        size -= to_read;
-        address += to_read;
-    }
-
-    let result: [u8; 16] = hasher.finalize().into();
-    Ok(result)
-}
-
 impl<'a> Stub<'a> {
     pub fn new(input_io: &'a mut dyn InputIO) -> Self {
-        Stub {
+        let stub = Stub {
             io: input_io,
             write_addr: 0,
             end_addr: 0,
@@ -88,7 +64,11 @@ impl<'a> Stub<'a> {
             decompressor: Default::default(),
             last_error: None,
             in_flash_mode: false,
-        }
+            target: Default::default(),
+        };
+
+        stub.target.init();
+        stub
     }
 
     fn send_response(&mut self, resp: &Response) {
@@ -117,11 +97,27 @@ impl<'a> Stub<'a> {
     }
 
     pub fn send_greeting(&mut self) {
-        let greeting = [b'O', b'H', b'A', b'I'];
+        let greeting = ['O' as u8, 'H' as u8, 'A' as u8, 'I' as u8];
         write_packet(self.io, &greeting);
     }
 
-    fn process_begin(&mut self, cmd: &commands::Begin) -> Result<(), Error> {
+    fn calculate_md5(&mut self, mut address: u32, mut size: u32) -> Result<[u8; 16], Error> {
+        let mut buffer: [u8; FLASH_SECTOR_SIZE as usize] = [0; FLASH_SECTOR_SIZE as usize];
+        let mut hasher = Md5::new();
+
+        while size > 0 {
+            let to_read = min(size, FLASH_SECTOR_SIZE);
+            self.target.spi_flash_read(address, &mut buffer)?;
+            hasher.update(&buffer[0..to_read as usize]);
+            size -= to_read;
+            address += to_read;
+        }
+
+        let result: [u8; 16] = hasher.finalize().into();
+        Ok(result)
+    }
+
+    fn process_begin(&mut self, cmd: &BeginCommand) -> Result<(), Error> {
         // Align erase addreess to sector boundady.
         self.erase_addr = cmd.offset & FLASH_SECTOR_MASK;
         self.write_addr = cmd.offset;
@@ -129,45 +125,51 @@ impl<'a> Stub<'a> {
         self.remaining_compressed = (cmd.packt_count * cmd.packet_size) as usize;
         self.remaining = cmd.total_size;
         self.decompressor.state = 0;
+        self.in_flash_mode = true;
 
         match cmd.base.code {
-            Code::FlashBegin | Code::FlashDeflBegin => {
+            FlashBegin | FlashDeflBegin => {
                 if cmd.packet_size > MAX_WRITE_BLOCK {
-                    return Err(Error::BadBlocksize);
+                    return Err(BadBlocksize);
                 }
                 // Todo: check for 16MB flash only
-                self.in_flash_mode = true;
-                unlock_flash()?;
+                self.target.unlock_flash()?;
             }
-            _ => (), // Do nothing for MemBegin
+            _ => (),
         }
 
         Ok(())
     }
 
-    fn process_end(&mut self, cmd: &commands::End, response: &Response) -> Result<(), Error> {
-        if cmd.base.code == Code::MemEnd {
-            let addr = self.erase_addr as *const u32;
-            let length = self.end_addr - self.erase_addr;
-            let slice = unsafe { slice::from_raw_parts(addr, length as usize) };
-            let mut memory: [u32; 32] = [0; 32];
-            memory.copy_from_slice(slice);
-            return match self.remaining {
-                0 => Ok(()),
-                _ => Err(Error::NotEnoughData),
-            };
-        } else if !self.in_flash_mode {
-            return Err(Error::NotInFlashMode);
+    fn process_flash_end(
+        &mut self,
+        cmd: &EndFlashCommand,
+        response: &Response,
+    ) -> Result<(), Error> {
+        if !self.in_flash_mode {
+            return Err(NotInFlashMode);
         } else if self.remaining > 0 {
-            return Err(Error::NotEnoughData);
+            return Err(NotEnoughData);
         }
 
         self.in_flash_mode = false;
 
         if cmd.run_user_code == 1 {
-            self.send_response(response);
-            delay_us(10000);
-            soft_reset();
+            self.send_response(&response);
+            self.target.delay_us(10000);
+            self.target.soft_reset();
+        }
+
+        Ok(())
+    }
+
+    fn process_mem_end(&mut self, cmd: &MemEndCommand, response: &Response) -> Result<(), Error> {
+        if self.remaining != 0 {
+            return Err(NotEnoughData);
+        } else if cmd.stay_in_stub == 0 {
+            self.send_response(&response);
+            self.target.delay_us(10000);
+            (cmd.entrypoint)();
         }
 
         Ok(())
@@ -177,9 +179,9 @@ impl<'a> Stub<'a> {
         let data_len = data.len() as u32;
 
         if data_len > self.remaining {
-            return Err(Error::TooMuchData);
+            return Err(TooMuchData);
         } else if data_len % 4 != 0 {
-            return Err(Error::BadDataLen);
+            return Err(BadDataLen);
         }
 
         let (_, data_u32, _) = unsafe { data.align_to::<u32>() };
@@ -188,12 +190,13 @@ impl<'a> Stub<'a> {
             let memory = self.write_addr as *mut u32;
             unsafe { *memory = *word };
             self.write_addr += 4;
+            self.remaining -= 4;
         }
 
         Ok(())
     }
 
-    fn flash(&mut self, flash_write: FlashFunc, data: &[u8]) {
+    fn flash(&mut self, encrypted: bool, data: &[u8]) {
         let mut address = self.write_addr;
         let mut remaining = min(self.remaining, data.len() as u32);
         let mut written = 0;
@@ -203,10 +206,10 @@ impl<'a> Stub<'a> {
             if self.end_addr >= self.erase_addr + FLASH_BLOCK_SIZE
                 && self.erase_addr % FLASH_BLOCK_SIZE == 0
             {
-                flash_erase_block(self.erase_addr);
+                self.target.flash_erase_block(self.erase_addr);
                 self.erase_addr += FLASH_BLOCK_SIZE;
             } else {
-                flash_erase_sector(self.erase_addr);
+                self.target.flash_erase_sector(self.erase_addr);
                 self.erase_addr += FLASH_SECTOR_SIZE;
             }
         }
@@ -215,7 +218,17 @@ impl<'a> Stub<'a> {
         while remaining > 0 {
             let to_write = min(FLASH_SECTOR_SIZE, remaining);
             let data_ptr = data[written..].as_ptr();
-            self.last_error = flash_write(address, data_ptr, to_write).err();
+            if encrypted {
+                self.last_error = self
+                    .target
+                    .write_encrypted(address, data_ptr, to_write)
+                    .err();
+            } else {
+                self.last_error = self
+                    .target
+                    .spiflash_write(address, data_ptr, to_write)
+                    .err();
+            }
             remaining -= to_write;
             written += to_write as usize;
             address += to_write;
@@ -226,12 +239,13 @@ impl<'a> Stub<'a> {
     }
 
     fn flash_data(&mut self, data: &[u8]) {
-        self.flash(spiflash_write, data);
+        self.flash(false, data);
     }
 
     fn flash_defl_data(&mut self, data: &[u8]) {
-        const OUT_BUFFER_SIZE: usize = 0x8000; // 32768;
+        use crate::miniz_types::TinflStatus::*;
 
+        const OUT_BUFFER_SIZE: usize = 0x8000; // 32768;
         static mut DECOMPRESS_BUF: [u8; OUT_BUFFER_SIZE] = [0; OUT_BUFFER_SIZE];
         static mut DECOMPRESS_INDEX: usize = 0;
 
@@ -239,10 +253,10 @@ impl<'a> Stub<'a> {
         let out_buf = unsafe { &mut DECOMPRESS_BUF };
         let mut in_index = 0;
         let mut length = data.len();
-        let mut status = TinflStatus::NeedsMoreInput;
+        let mut status = NeedsMoreInput;
         let mut flags = TINFL_FLAG_PARSE_ZLIB_HEADER;
 
-        while length > 0 && self.remaining > 0 && status != TinflStatus::Done {
+        while length > 0 && self.remaining > 0 && status != Done {
             let mut in_bytes = length;
             let mut out_bytes = out_buf.len() - out_index;
             let next_out: *mut u8 = out_buf[out_index..].as_mut_ptr();
@@ -251,7 +265,7 @@ impl<'a> Stub<'a> {
                 flags |= TINFL_FLAG_HAS_MORE_INPUT;
             }
 
-            status = target::decompress(
+            status = self.target.decompress(
                 &mut self.decompressor,
                 data[in_index..].as_ptr(),
                 &mut in_bytes,
@@ -266,7 +280,7 @@ impl<'a> Stub<'a> {
             in_index += in_bytes;
             out_index += out_bytes;
 
-            if status == TinflStatus::Done || out_index == OUT_BUFFER_SIZE {
+            if status == Done || out_index == OUT_BUFFER_SIZE {
                 self.flash_data(&out_buf[..out_index]);
                 out_index = 0;
             }
@@ -275,51 +289,51 @@ impl<'a> Stub<'a> {
         unsafe { DECOMPRESS_INDEX = out_index };
 
         // error won't get sent back until next block is sent
-        if status < TinflStatus::Done {
-            self.last_error = Some(Error::Inflate);
-        } else if status == TinflStatus::Done && self.remaining > 0 {
-            self.last_error = Some(Error::NotEnoughData);
-        } else if status != TinflStatus::Done && self.remaining == 0 {
-            self.last_error = Some(Error::TooMuchData);
+        if status < Done {
+            self.last_error = Some(InflateError);
+        } else if status == Done && self.remaining > 0 {
+            self.last_error = Some(NotEnoughData);
+        } else if status != Done && self.remaining == 0 {
+            self.last_error = Some(TooMuchData);
         }
     }
 
     fn flash_encrypt_data(&mut self, data: &[u8]) {
-        write_encrypted_enable();
-        self.flash(write_encrypted, data);
-        write_encrypted_disable();
+        self.target.write_encrypted_enable();
+        self.flash(true, data);
+        self.target.write_encrypted_disable();
     }
 
     fn process_data(
         &mut self,
-        cmd: &commands::Data,
+        cmd: &DataCommand,
         data: &[u8],
         response: &Response,
     ) -> Result<(), Error> {
         let checksum: u8 = data.iter().fold(0xEF, |acc, x| acc ^ x);
 
         if !self.in_flash_mode {
-            return Err(Error::NotInFlashMode);
+            return Err(NotInFlashMode);
         } else if cmd.size != data.len() as u32 {
-            return Err(Error::BadDataLen);
+            return Err(BadDataLen);
         } else if cmd.base.checksum != checksum as u32 {
-            return Err(Error::BadDataChecksum);
+            return Err(BadDataChecksum);
         }
 
-        self.send_response(response);
+        self.send_response(&response);
 
         match cmd.base.code {
-            Code::FlashEncryptedData => self.flash_encrypt_data(data),
-            Code::FlashDeflData => self.flash_defl_data(data),
-            Code::FlashData => self.flash_data(data),
-            Code::MemData => self.write_ram(data)?,
+            FlashEncryptedData => self.flash_encrypt_data(data),
+            FlashDeflData => self.flash_defl_data(data),
+            FlashData => self.flash_data(data),
+            MemData => self.write_ram(data)?,
             _ => (),
         }
 
         Ok(())
     }
 
-    fn process_read_flash(&mut self, params: &commands::ReadFlashParams) -> Result<(), Error> {
+    fn process_read_flash(&mut self, params: &ReadFlashParams) -> Result<(), Error> {
         const BUF_SIZE: usize = FLASH_SECTOR_SIZE as usize;
         let mut buffer: [u8; BUF_SIZE] = [0; BUF_SIZE];
         let mut address = params.address;
@@ -333,7 +347,8 @@ impl<'a> Stub<'a> {
         while acked < params.total_size {
             while remaining > 0 && sent < (acked + max_inflight_bytes) {
                 let len = min(params.packet_size, remaining);
-                spi_flash_read(address, &mut buffer[..len as usize])?;
+                self.target
+                    .spi_flash_read(address, &mut buffer[..len as usize])?;
                 write_packet(self.io, &buffer[..len as usize]);
                 hasher.update(&buffer[0..len as usize]);
                 remaining -= len;
@@ -350,87 +365,91 @@ impl<'a> Stub<'a> {
     }
 
     #[allow(unreachable_patterns)]
-    fn execute_command(
+    fn process_cmd(
         &mut self,
         payload: &[u8],
-        code: Code,
+        code: CommandCode,
         response: &mut Response,
     ) -> Result<bool, Error> {
         let mut response_sent = false;
 
-        dprintln!("process command: {:?}", code);
+        crate::dprintln!("process command: {:?}", code);
 
         match code {
-            Code::Sync => {
+            Sync => {
                 for _ in 1..=7 {
-                    self.send_response(response);
+                    self.send_response(&response);
                 }
             }
-            Code::ReadReg => {
+            ReadReg => {
                 let address = u32_from_slice(payload, CMD_BASE_SIZE);
-                response.value(read_register(address));
+                response.value(self.target.read_register(address));
             }
-            Code::WriteReg => {
-                let reg: commands::WriteReg = slice_to_struct(payload)?;
-                write_register(reg.address, reg.value);
+            WriteReg => {
+                let reg: WriteRegCommand = slice_to_struct(payload)?;
+                self.target.write_register(reg.address, reg.value);
             }
-            Code::FlashBegin | Code::MemBegin | Code::FlashDeflBegin => {
-                let cmd: commands::Begin = slice_to_struct(payload)?;
+            FlashBegin | MemBegin | FlashDeflBegin => {
+                let cmd: BeginCommand = slice_to_struct(payload)?;
                 self.process_begin(&cmd)?
             }
-            Code::FlashData | Code::FlashDeflData | Code::FlashEncryptedData | Code::MemData => {
-                let cmd: commands::Data = slice_to_struct(payload)?;
+            FlashData | FlashDeflData | FlashEncryptedData | MemData => {
+                let cmd: DataCommand = slice_to_struct(&payload)?;
                 let data = &payload[DATA_CMD_SIZE..];
-                self.process_data(&cmd, data, response)?;
+                self.process_data(&cmd, data, &response)?;
                 response_sent = true;
             }
-            Code::FlashEnd | Code::MemEnd | Code::FlashDeflEnd => {
-                let cmd: commands::End = slice_to_struct(payload)?;
-                self.process_end(&cmd, response)?;
+            FlashEnd | FlashDeflEnd => {
+                let cmd: EndFlashCommand = slice_to_struct(payload)?;
+                self.process_flash_end(&cmd, &response)?;
+            }
+            MemEnd => {
+                let cmd: MemEndCommand = slice_to_struct(payload)?;
+                self.process_mem_end(&cmd, &response)?;
             }
-            Code::SpiFlashMd5 => {
-                let cmd: commands::SpiFlashMd5 = slice_to_struct(payload)?;
-                let md5 = calculate_md5(cmd.address, cmd.size)?;
-                self.send_md5_response(response, &md5);
+            SpiFlashMd5 => {
+                let cmd: SpiFlashMd5Command = slice_to_struct(payload)?;
+                let md5 = self.calculate_md5(cmd.address, cmd.size)?;
+                self.send_md5_response(&response, &md5);
                 response_sent = true;
             }
-            Code::SpiSetParams => {
-                let cmd: commands::SpiSetParams = slice_to_struct(payload)?;
-                spi_set_params(&cmd.params)?
+            SpiSetParams => {
+                let cmd: SpiSetParamsCommand = slice_to_struct(payload)?;
+                self.target.spi_set_params(&cmd.params)?
             }
-            Code::SpiAttach => {
+            SpiAttach => {
                 let param = u32_from_slice(payload, CMD_BASE_SIZE);
-                spi_attach(param);
+                self.target.spi_attach(param);
             }
-            Code::ChangeBaudrate => {
-                let baud: commands::ChangeBaudrate = slice_to_struct(payload)?;
-                self.send_response(response);
-                delay_us(10000); // Wait for response to be transfered
-                change_baudrate(baud.old, baud.new);
+            ChangeBaudrate => {
+                let baud: ChangeBaudrateCommand = slice_to_struct(payload)?;
+                self.send_response(&response);
+                self.target.delay_us(10000); // Wait for response to be transfered
+                self.target.change_baudrate(baud.old, baud.new);
                 self.send_greeting();
                 response_sent = true;
             }
-            Code::EraseFlash => erase_flash()?,
-            Code::EraseRegion => {
-                let reg: commands::EraseRegion = slice_to_struct(payload)?;
-                erase_region(reg.address, reg.size)?;
+            EraseFlash => self.target.erase_flash()?,
+            EraseRegion => {
+                let reg: EraseRegionCommand = slice_to_struct(payload)?;
+                self.target.erase_region(reg.address, reg.size)?;
             }
-            Code::ReadFlash => {
-                self.send_response(response);
-                let cmd: commands::ReadFlash = slice_to_struct(payload)?;
+            ReadFlash => {
+                self.send_response(&response);
+                let cmd: ReadFlashCommand = slice_to_struct(payload)?;
                 self.process_read_flash(&cmd.params)?;
                 response_sent = true;
             }
-            Code::GetSecurityInfo => {
-                let info = get_security_info()?;
-                self.send_security_info_response(response, &info);
+            GetSecurityInfo => {
+                let info = self.target.get_security_info()?;
+                self.send_security_info_response(&response, &info);
                 response_sent = true;
             }
-            Code::RunUserCode => {
-                soft_reset(); // ESP8266 Only
+            RunUserCode => {
+                self.target.soft_reset(); // ESP8266 Only
             }
             _ => {
-                return Err(Error::InvalidCommand);
+                return Err(InvalidCommand);
             }
         };
 
@@ -438,10 +457,10 @@ impl<'a> Stub<'a> {
     }
 
     pub fn process_command(&mut self, payload: &[u8]) {
-        let command: commands::Base = slice_to_struct(payload).unwrap();
+        let command: CommandBase = slice_to_struct(&payload).unwrap();
         let mut response = Response::new(command.code);
 
-        match self.execute_command(payload, command.code, &mut response) {
+        match self.process_cmd(payload, command.code, &mut response) {
             Ok(response_sent) => match response_sent {
                 true => return,
                 false => (),
@@ -460,13 +479,6 @@ impl<'a> Stub<'a> {
 mod slip {
     use super::*;
 
-    pub const DELIMITER: u8 = 0xC0;
-    pub const ESCAPE: u8 = 0xDB;
-    pub const DELIMITER_END: u8 = 0xDC;
-    pub const ESCAPE_END: u8 = 0xDD;
-    pub const DELIMITER_REPLACEMNT: &[u8; 2] = &[0xDB, 0xDC];
-    pub const ESCAPE_REPLACEMNT: &[u8; 2] = &[0xDB, 0xDD];
-
     pub fn read_packet<'c, 'd>(io: &'c mut dyn InputIO, packet: &'d mut [u8]) -> &'d [u8] {
         while io.recv() != 0xC0 {}
 
@@ -474,12 +486,12 @@ mod slip {
         let mut i = 0;
         loop {
             match io.recv() {
-                ESCAPE => match io.recv() {
-                    DELIMITER_END => packet[i] = DELIMITER,
-                    ESCAPE_END => packet[i] = ESCAPE,
+                0xDB => match io.recv() {
+                    0xDC => packet[i] = 0xC0,
+                    0xDD => packet[i] = 0xDB,
                     _ => continue, // Framing error, continue processing
                 },
-                DELIMITER => break,
+                0xC0 => break,
                 other => packet[i] = other,
             };
             i += 1;
@@ -491,8 +503,8 @@ mod slip {
     pub fn write_raw(io: &mut dyn InputIO, data: &[u8]) {
         for byte in data {
             match byte {
-                &DELIMITER => io.send(DELIMITER_REPLACEMNT),
-                &ESCAPE => io.send(ESCAPE_REPLACEMNT),
+                0xC0 => io.send(&[0xDB, 0xDC]),
+                0xDB => io.send(&[0xDB, 0xDD]),
                 other => io.send(&[*other]),
             }
         }
@@ -508,397 +520,3 @@ mod slip {
         io.send(&[0xC0]);
     }
 }
-
-#[cfg(test)]
-mod tests {
-    use std::{collections::VecDeque, vec::Vec};
-
-    use assert2::{assert, let_assert};
-    use mockall::predicate;
-
-    use super::{
-        slip::{read_packet, write_raw},
-        *,
-    };
-    use crate::commands::*;
-
-    struct MockIO {
-        data: VecDeque<u8>,
-    }
-
-    impl MockIO {
-        fn from_slice(bytes: &[u8]) -> Self {
-            let bytes_vec = Vec::from(bytes);
-            MockIO {
-                data: VecDeque::from(bytes_vec),
-            }
-        }
-
-        fn new() -> Self {
-            MockIO {
-                data: VecDeque::new(),
-            }
-        }
-
-        fn fill(&mut self, bytes: &[u8]) {
-            self.data.clear();
-            self.data.extend(bytes);
-        }
-
-        fn clear(&mut self) {
-            self.data.clear();
-        }
-
-        fn written(&mut self) -> &[u8] {
-            self.data.make_contiguous()
-        }
-    }
-
-    impl InputIO for MockIO {
-        fn read(&mut self) -> Result<u8, ErrorIO> {
-            match self.data.pop_front() {
-                Some(top) => Ok(top),
-                None => Err(Incomplete),
-            }
-        }
-
-        fn write(&mut self, bytes: &[u8]) -> Result<(), ErrorIO> {
-            self.data.extend(bytes);
-            Ok(())
-        }
-    }
-
-    #[test]
-    fn test_read_packet() {
-        let mut io = MockIO::new();
-        let mut buffer: Buffer = heapless::Vec::new();
-
-        // Returns Incomplete when packet enclosed by 0xC0 was not found
-        io.fill(&[0xC0, 0xAA, 0x22]);
-        assert!(read_packet(&mut io, &mut buffer) == Err(Incomplete));
-
-        // Returns Incomplete when no 0xC0 is found
-        io.fill(&[0x00, 0xAA, 0x22]);
-        assert!(read_packet(&mut io, &mut buffer) == Err(Incomplete));
-
-        // Can find packet by 0xC0
-        io.fill(&[0xC0, 0x11, 0x22, 0xC0]);
-        assert!(read_packet(&mut io, &mut buffer) == Ok(()));
-        assert!(buffer.as_slice() == &[0x11, 0x22]);
-
-        // Can find packet by 0xC0
-        io.fill(&[0xC0, 0x11, 0x22, 0xC0]);
-        assert!(read_packet(&mut io, &mut buffer) == Ok(()));
-        assert!(buffer.as_slice() == &[0x11, 0x22]);
-
-        // Can convert 0xDB 0xDC -> 0xC0
-        io.fill(&[0xC0, 0x11, 0xDB, 0xDC, 0x22, 0xC0]);
-        assert!(read_packet(&mut io, &mut buffer) == Ok(()));
-        assert!(buffer.as_slice() == &[0x11, 0xC0, 0x22]);
-
-        // Can convert 0xDB 0xDD -> 0xDB
-        io.fill(&[0xC0, 0x11, 0xDB, 0xDD, 0x22, 0xC0]);
-        assert!(read_packet(&mut io, &mut buffer) == Ok(()));
-        assert!(buffer.as_slice() == &[0x11, 0xDB, 0x22]);
-
-        // Returns InvalidResponse after invalid byte pair
-        io.fill(&[0xC0, 0x11, 0xDB, 0x22, 0xDB, 0x33, 0x44, 0xC0]);
-        assert!(read_packet(&mut io, &mut buffer) == Err(InvalidResponse));
-    }
-
-    #[test]
-    fn test_write_raw() {
-        let mut io = MockIO::new();
-
-        // 0xC0 is replaced with 0xDB 0xDC
-        assert!(write_raw(&mut io, &[1, 0xC0, 3]) == Ok(()));
-        assert!(io.written() == &[1, 0xDB, 0xDC, 3]);
-        io.clear();
-
-        // 0xDB is replaced with 0xDB 0xDD
-        assert!(write_raw(&mut io, &[1, 0xDB, 3]) == Ok(()));
-        assert!(io.written() == &[1, 0xDB, 0xDD, 3]);
-        io.clear();
-    }
-
-    #[test]
-    fn test_wait_for_packet() {
-        let mut dummy = CommandCode::Sync;
-        // Check FlashBegin command
-        let mut io = MockIO::from_slice(&[
-            0xC0,
-            0, // direction
-            CommandCode::FlashBegin as u8,
-            16,
-            0, // size
-            1,
-            0,
-            0,
-            0, // checksum
-            2,
-            0,
-            0,
-            0, // erase_addr
-            3,
-            0,
-            0,
-            0, // packt_count
-            4,
-            0,
-            0,
-            0, // packet_size
-            5,
-            0,
-            0,
-            0, // offset
-            0xC0,
-        ]);
-        let mut stub = Stub::new(&mut io);
-        let_assert!(Ok(Command::Begin(cmd)) = stub.wait_for_command(&mut dummy));
-        assert!({ cmd.base.direction == 0 });
-        assert!({ cmd.base.code == CommandCode::FlashBegin });
-        assert!({ cmd.base.size == 16 });
-        assert!({ cmd.base.checksum == 1 });
-        assert!({ cmd.total_size == 2 });
-        assert!({ cmd.packt_count == 3 });
-        assert!({ cmd.packet_size == 4 });
-        assert!({ cmd.offset == 5 });
-
-        // Check FlashData command
-        let mut io = MockIO::from_slice(&[
-            0xC0,
-            0, // direction
-            CommandCode::FlashData as u8,
-            20,
-            0, // size
-            1,
-            0,
-            0,
-            0, // checksum
-            4,
-            0,
-            0,
-            0, // size
-            3,
-            0,
-            0,
-            0, // sequence_num
-            0,
-            0,
-            0,
-            0, // reserved 1
-            0,
-            0,
-            0,
-            0, // reserved 1
-            9,
-            8,
-            7,
-            6, // payload
-            0xC0,
-        ]);
-        let mut stub = Stub::new(&mut io);
-        let_assert!(Ok(Command::Data(cmd, data)) = stub.wait_for_command(&mut dummy));
-        assert!({ cmd.base.code == CommandCode::FlashData });
-        assert!({ cmd.base.size == 20 });
-        assert!({ cmd.base.checksum == 1 });
-        assert!({ cmd.size == 4 });
-        assert!({ cmd.sequence_num == 3 });
-        assert!({ cmd.reserved[0] == 0 });
-        assert!({ cmd.reserved[1] == 0 });
-        assert!(data == &[9, 8, 7, 6]);
-
-        // Check Sync command
-        let mut io = MockIO::from_slice(&[
-            0xC0,
-            0, // direction
-            CommandCode::Sync as u8,
-            36,
-            0, // size
-            1,
-            0,
-            0,
-            0, // checksum
-            0x7,
-            0x7,
-            0x12,
-            0x20,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0x55,
-            0xC0,
-        ]);
-        let mut stub = Stub::new(&mut io);
-        let_assert!(Ok(Command::Sync(_)) = stub.wait_for_command(&mut dummy));
-
-        // Check ReadReg command
-        let mut io = MockIO::from_slice(&[
-            0xC0,
-            0, // direction
-            CommandCode::ReadReg as u8,
-            4,
-            0, // size
-            1,
-            0,
-            0,
-            0, // checksum
-            200,
-            0,
-            0,
-            0, // address
-            0xC0,
-        ]);
-        let mut stub = Stub::new(&mut io);
-        let_assert!(Ok(Command::ReadReg(address)) = stub.wait_for_command(&mut dummy));
-        assert!(address == 200);
-    }
-
-    #[test]
-    fn test_send_response() {
-        // Can write error response
-        let mut io = MockIO::new();
-        let mut stub = Stub::new(&mut io);
-        let mut response = Response::new(CommandCode::FlashBegin);
-        response.error(Error::BadDataChecksum);
-        let expected = &[
-            0xC0,
-            1,
-            CommandCode::FlashBegin as u8,
-            2,
-            0,
-            0,
-            0,
-            0,
-            0,
-            1,
-            Error::BadDataChecksum as u8,
-            0xC0,
-        ];
-        assert!(stub.send_response(&response) == Ok(()));
-        assert!(io.written() == expected);
-
-        // Can write response with data
-        let mut io = MockIO::new();
-        let mut stub = Stub::new(&mut io);
-        let data = &[1, 2, 3, 4, 5, 6, 7, 8];
-        let mut response = Response::new(CommandCode::FlashBegin);
-        response.data(data);
-        let expected = &[
-            0xC0,
-            1,
-            CommandCode::FlashBegin as u8,
-            10,
-            0,
-            0,
-            0,
-            0,
-            0,
-            0,
-            0,
-            1,
-            2,
-            3,
-            4,
-            5,
-            6,
-            7,
-            8,
-            0xC0,
-        ];
-        assert!(stub.send_response(&response) == Ok(()));
-        assert!(io.written() == expected);
-    }
-
-    fn decorate_command<T>(data: T) -> Vec<u8> {
-        let mut v = Vec::new();
-        v.push(0xC0);
-        v.extend_from_slice(unsafe { to_slice_u8(&data) });
-        v.push(0xC0);
-        v
-    }
-
-    #[repr(C, packed(1))]
-    pub struct TestResponse {
-        pub direction: u8,
-        pub command: CommandCode,
-        pub size: u16,
-        pub value: u32,
-        pub status: u8,
-        pub error: u8,
-    }
-
-    #[test]
-    fn test_read_register() {
-        let cmd = ReadRegCommand {
-            base: CommandBase {
-                direction: 1,
-                code: CommandCode::ReadReg,
-                size: 4,
-                checksum: 0,
-            },
-            address: 200,
-        };
-        let mut io = MockIO::from_slice(&decorate_command(cmd));
-        let mut stub = Stub::new(&mut io);
-
-        let ctx = target::read_register_context();
-        ctx.expect().with(predicate::eq(200)).returning(|x| x + 1);
-        assert!(Ok(()) == stub.process_commands());
-
-        let expect = &[
-            0xC0,
-            1,
-            CommandCode::ReadReg as u8,
-            2,
-            0,
-            201,
-            0,
-            0,
-            0,
-            0,
-            0,
-            0xC0,
-        ];
-        assert!(io.written() == expect);
-    }
-
-    #[test]
-    fn test_mock() {
-        let mut io = MockIO::new();
-
-        io.fill(&[1, 2, 3]);
-        assert!(io.recv() == Ok(1));
-        assert!(io.recv() == Ok(2));
-        assert!(io.recv() == Ok(3));
-        assert!(io.recv() == Err(Incomplete));
-    }
-}
diff --git a/src/serial_io.rs b/src/serial_io.rs
index eb57f02..3ef60eb 100644
--- a/src/serial_io.rs
+++ b/src/serial_io.rs
@@ -1,25 +1,31 @@
-use esp32c3_hal::{
-    interrupt,
-    interrupt::CpuInterrupt,
-    pac::{self, UART0},
-    prelude::*,
-    serial::Instance,
-    Cpu, Serial,
+use heapless::Deque;
+#[cfg(any(target_arch = "riscv32"))]
+use riscv::interrupt::free as interrupt_free;
+#[cfg(any(target_arch = "xtensa"))]
+use xtensa_lx::interrupt::free as interrupt_free;
+
+use crate::{
+    hal::{
+        interrupt,
+        interrupt::CpuInterrupt::*,
+        pac,
+        pac::UART0,
+        prelude::*,
+        serial::Instance,
+        Cpu::*,
+        Serial,
+    },
+    protocol::InputIO,
 };
-use heapless::spsc::Queue;
 
-use crate::{protocol::InputIO, targets::esp32c3 as target};
+const RX_QUEUE_SIZE: usize = crate::targets::MAX_WRITE_BLOCK + 0x400;
 
-const RX_QUEUE_SIZE: usize = target::MAX_WRITE_BLOCK + 0x400;
-static mut RX_QUEUE: Queue<u8, RX_QUEUE_SIZE> = Queue::new();
+static mut RX_QUEUE: Deque<u8, RX_QUEUE_SIZE> = Deque::new();
 
-impl<T: Instance> InputIO for Serial<T> {
+impl<'a, T: Instance> InputIO for Serial<T> {
     fn recv(&mut self) -> u8 {
-        loop {
-            if let Some(byte) = unsafe { RX_QUEUE.dequeue() } {
-                return byte;
-            }
-        }
+        unsafe { while interrupt_free(|_| RX_QUEUE.is_empty()) {} }
+        unsafe { interrupt_free(|_| RX_QUEUE.pop_front().unwrap()) }
     }
 
     fn send(&mut self, bytes: &[u8]) {
@@ -27,15 +33,57 @@ impl<T: Instance> InputIO for Serial<T> {
     }
 }
 
-#[interrupt]
-fn UART0() {
+fn uart_isr() {
     let uart = unsafe { &*UART0::ptr() };
 
     while uart.status.read().rxfifo_cnt().bits() > 0 {
         let data = uart.fifo.read().rxfifo_rd_byte().bits();
-        unsafe { RX_QUEUE.enqueue(data).unwrap() };
+        unsafe { RX_QUEUE.push_back(data).unwrap() };
     }
 
     uart.int_clr.write(|w| w.rxfifo_full_int_clr().set_bit());
-    interrupt::clear(Cpu::ProCpu, CpuInterrupt::Interrupt3);
+}
+
+#[cfg(feature = "esp32")]
+pub fn enable_uart0_rx_interrupt() {
+    let uart = unsafe { &*UART0::ptr() };
+
+    uart.conf1
+        .modify(|_, w| unsafe { w.rxfifo_full_thrhd().bits(1) });
+    uart.int_ena.write(|w| w.rxfifo_full_int_ena().set_bit());
+
+    unsafe {
+        interrupt::map(ProCpu, pac::Interrupt::UART0, Interrupt17LevelPriority1);
+        xtensa_lx::interrupt::enable_mask(1 << 17);
+    }
+}
+
+#[cfg(feature = "esp32c3")]
+pub fn enable_uart0_rx_interrupt() {
+    let uart = unsafe { &*UART0::ptr() };
+
+    uart.conf1
+        .modify(|_, w| unsafe { w.rxfifo_full_thrhd().bits(1) });
+    uart.int_ena.write(|w| w.rxfifo_full_int_ena().set_bit());
+
+    interrupt::enable(pac::Interrupt::UART0, interrupt::Priority::Priority1).unwrap();
+    interrupt::set_kind(ProCpu, Interrupt1, interrupt::InterruptKind::Level);
+
+    unsafe {
+        riscv::interrupt::enable();
+    }
+}
+
+#[interrupt]
+#[cfg(feature = "esp32")]
+fn UART0() {
+    uart_isr();
+    interrupt::clear(ProCpu, Interrupt17LevelPriority1);
+}
+
+#[interrupt]
+#[cfg(feature = "esp32c3")]
+fn UART0() {
+    uart_isr();
+    interrupt::clear(ProCpu, Interrupt1);
 }
diff --git a/src/targets.rs b/src/targets.rs
index bee8165..46725fe 100644
--- a/src/targets.rs
+++ b/src/targets.rs
@@ -1,13 +1,26 @@
-use crate::miniz_types::{tinfl_decompress, tinfl_decompressor, TinflStatus};
+use core::ptr::{read_volatile, write_volatile};
+
+use crate::{
+    commands::{Error::*, *},
+    miniz_types::*,
+};
+
+#[repr(C, packed(1))]
+struct RomSpiFlashChip {
+    device_id: u32,
+    chip_size: u32,
+    block_size: u32,
+    sector_size: u32,
+    page_size: u32,
+    status_mask: u32,
+}
 
 #[allow(unused)]
 extern "C" {
     fn esp_rom_spiflash_erase_chip() -> i32;
     fn esp_rom_spiflash_erase_block(block_number: u32) -> i32;
     fn esp_rom_spiflash_erase_sector(sector_number: u32) -> i32;
-    /// address (4 byte alignment), data, length
     fn esp_rom_spiflash_write(dest_addr: u32, data: *const u8, len: u32) -> i32;
-    /// address (4 byte alignment), data, length
     fn esp_rom_spiflash_read(src_addr: u32, data: *const u8, len: u32) -> i32;
     fn esp_rom_spiflash_unlock() -> i32;
     fn esp_rom_spiflash_attach(config: u32, legacy: bool);
@@ -24,27 +37,35 @@ extern "C" {
     fn ets_efuse_get_spiconfig() -> u32;
     fn software_reset();
     fn ets_delay_us(timeout: u32);
-    fn GetSecurityInfoProc(pMsg: u8, pnErr: u8, data: *const u8) -> u32;
+    fn get_security_info_proc(pMsg: u8, pnErr: u8, data: *const u8) -> u32;
     fn esp_rom_spiflash_write_encrypted_enable();
     fn esp_rom_spiflash_write_encrypted_disable();
+    fn spi_write_status(chip: *const RomSpiFlashChip, status: u32) -> u32;
     fn esp_rom_spiflash_write_encrypted(dest_addr: u32, data: *const u8, len: u32) -> i32;
+    // fn spi_read_status_high(spi: *const RomSpiFlashChip, status: *const u32) ->
+    // u32;
+    fn spi_read_status_high(status: *const u32) -> u32;
 }
 
-#[cfg_attr(test, mockall::automock)]
-pub mod esp32c3 {
-    use core::ptr::{read_volatile, write_volatile};
+const SECURITY_INFO_BYTES: usize = 20;
 
-    use super::*;
-    use crate::commands::{Error, SpiParams};
+pub const FLASH_SECTOR_SIZE: u32 = 4096;
+pub const FLASH_BLOCK_SIZE: u32 = 65536;
+pub const FLASH_SECTOR_MASK: u32 = 0xFFFFF000;
+pub const MAX_WRITE_BLOCK: usize = 0x4000;
 
+pub trait EspCommon {
     const SPI_BASE_REG: u32 = 0x60002000;
-    const SPI_CMD_REG: u32 = SPI_BASE_REG;
-    const SPI_ADDR_REG: u32 = SPI_BASE_REG + 0x04;
-    const SPI_RD_STATUS_REG: u32 = SPI_BASE_REG + 0x2C;
-    const SPI_EXT2_REG: u32 = SPI_BASE_REG + 0x54;
-
+    const SPI_RD_STATUS_REG: u32 = Self::SPI_BASE_REG + 0x2C;
+    const SPI_EXT2_REG: u32 = Self::SPI_BASE_REG + 0x54;
     const SPI0_BASE_REG: u32 = 0x60003000;
-    const SPI0_EXT2_REG: u32 = SPI0_BASE_REG + 0x54;
+    const SPI0_EXT2_REG: u32 = Self::SPI0_BASE_REG + 0x54;
+    const UART_BASE_REG: u32 = 0x60000000;
+    const GPIO_BASE_REG: u32 = 0x60004000;
+
+    const SPI_CMD_REG: u32 = Self::SPI_BASE_REG + 0x00;
+    const SPI_ADDR_REG: u32 = Self::SPI_BASE_REG + 0x04;
+    const SPI_CTRL_REG: u32 = Self::SPI_BASE_REG + 0x08;
 
     const SPI_ST: u32 = 0x7;
     const SPI_FLASH_RDSR: u32 = 1 << 27;
@@ -53,18 +74,12 @@ pub mod esp32c3 {
     const SPI_FLASH_SE: u32 = 1 << 24;
     const SPI_FLASH_BE: u32 = 1 << 23;
 
-    const UART_BASE_REG: u32 = 0x60000000;
-    const UART0_CLKDIV_REG: u32 = UART_BASE_REG + 0x14;
+    const UART0_CLKDIV_REG: u32 = Self::UART_BASE_REG + 0x14;
     const UART_CLKDIV_M: u32 = 0x000FFFFF;
     const UART_CLKDIV_FRAG_S: u32 = 20;
     const UART_CLKDIV_FRAG_V: u32 = 0xF;
-    pub const FLASH_SECTOR_SIZE: u32 = 4096;
-    pub const FLASH_BLOCK_SIZE: u32 = 65536;
-    pub const FLASH_SECTOR_MASK: u32 = 0xFFFFF000;
-    pub const MAX_WRITE_BLOCK: usize = 0x4000;
 
-    const GPIO_BASE_REG: u32 = 0x60004000;
-    const GPIO_STRAP_REG: u32 = GPIO_BASE_REG + 0x38;
+    const GPIO_STRAP_REG: u32 = Self::GPIO_BASE_REG + 0x38;
 
     const FLASH_MAX_SIZE: u32 = 16 * 1024 * 1024;
     const FLASH_PAGE_SIZE: u32 = 256;
@@ -72,30 +87,34 @@ pub mod esp32c3 {
 
     const SECURITY_INFO_BYTES: usize = 20;
 
-    fn get_uart_div(current_baud: u32, new_baud: u32) -> u32 {
-        let clock_div_reg = read_register(UART0_CLKDIV_REG);
-        let uart_div = clock_div_reg & UART_CLKDIV_M;
-        let fraction = (clock_div_reg >> UART_CLKDIV_FRAG_S) & UART_CLKDIV_FRAG_V;
+    fn get_uart_div(&self, current_baud: u32, new_baud: u32) -> u32 {
+        let clock_div_reg = self.read_register(Self::UART0_CLKDIV_REG);
+        let uart_div = clock_div_reg & Self::UART_CLKDIV_M;
+        let fraction = (clock_div_reg >> Self::UART_CLKDIV_FRAG_S) & Self::UART_CLKDIV_FRAG_V;
         let uart_div = (uart_div << 4) + fraction;
         (uart_div * current_baud) / new_baud
     }
 
-    pub fn read_register(address: u32) -> u32 {
+    fn read_register(&self, address: u32) -> u32 {
         unsafe { read_volatile(address as *const u32) }
     }
 
-    pub fn write_register(address: u32, value: u32) {
+    fn write_register(&self, address: u32, value: u32) {
         unsafe { write_volatile(address as *mut _, value) }
     }
 
-    pub fn spiflash_write(dest_addr: u32, data: *const u8, len: u32) -> Result<(), Error> {
+    fn set_register_mask(&self, address: u32, mask: u32) {
+        self.write_register(address, self.read_register(address) | mask);
+    }
+
+    fn spiflash_write(&self, dest_addr: u32, data: *const u8, len: u32) -> Result<(), Error> {
         match unsafe { esp_rom_spiflash_write(dest_addr, data, len) } {
             0 => Ok(()),
-            _ => Err(Error::FailedSpiOp),
+            _ => Err(FailedSpiOp),
         }
     }
 
-    pub fn spi_set_params(params: &SpiParams) -> Result<(), Error> {
+    fn spi_set_params(&self, params: &SpiParams) -> Result<(), Error> {
         let result = unsafe {
             esp_rom_spiflash_config_param(
                 params.id,
@@ -110,74 +129,77 @@ pub mod esp32c3 {
         if result == 0 {
             Ok(())
         } else {
-            Err(Error::FailedSpiOp)
+            Err(FailedSpiOp)
         }
     }
 
-    pub fn spi_attach(param: u32) {
+    fn spi_attach(&self, param: u32) {
         unsafe { esp_rom_spiflash_attach(param, false) };
     }
 
-    pub fn change_baudrate(old: u32, new: u32) {
-        unsafe { uart_div_modify(0, get_uart_div(old, new)) };
+    fn change_baudrate(&self, old: u32, new: u32) {
+        unsafe { uart_div_modify(0, self.get_uart_div(old, new)) };
     }
 
-    pub fn erase_flash() -> Result<(), Error> {
+    fn erase_flash(&self) -> Result<(), Error> {
         // Returns 1 or 2 in case of failure
         match unsafe { esp_rom_spiflash_erase_chip() } {
             0 => Ok(()),
-            _ => Err(Error::FailedSpiOp),
+            _ => Err(FailedSpiOp),
         }
     }
 
-    fn erase(address: u32, block: bool) {
-        spiflash_wait_for_ready();
-        spi_write_enable();
-        wait_for_ready();
+    fn erase(&self, address: u32, block: bool) {
+        self.spiflash_wait_for_ready();
+        self.spi_write_enable();
+        self.wait_for_ready();
 
-        let command = if block { SPI_FLASH_BE } else { SPI_FLASH_SE };
-        write_register(SPI_ADDR_REG, address);
-        write_register(SPI_CMD_REG, command);
-        while read_register(SPI_CMD_REG) != 0 {}
+        let command = if block {
+            Self::SPI_FLASH_BE
+        } else {
+            Self::SPI_FLASH_SE
+        };
+        self.write_register(Self::SPI_ADDR_REG, address);
+        self.write_register(Self::SPI_CMD_REG, command);
+        while self.read_register(Self::SPI_CMD_REG) != 0 {}
 
-        spiflash_wait_for_ready();
+        self.spiflash_wait_for_ready();
     }
 
-    fn wait_for_ready() {
-        while (read_register(SPI_EXT2_REG) & SPI_ST) != 0 {}
-        while (read_register(SPI0_EXT2_REG) & SPI_ST) != 0 {} // ESP32_OR_LATER
+    fn wait_for_ready(&self) {
+        while (self.read_register(Self::SPI_EXT2_REG) & Self::SPI_ST) != 0 {}
+        while (self.read_register(Self::SPI0_EXT2_REG) & Self::SPI_ST) != 0 {} // ESP32_OR_LATER
     }
 
-    fn spiflash_wait_for_ready() {
-        wait_for_ready();
+    fn spiflash_wait_for_ready(&self) {
+        self.wait_for_ready();
 
-        write_register(SPI_RD_STATUS_REG, 0);
-        write_register(SPI_CMD_REG, SPI_FLASH_RDSR);
-        while read_register(SPI_CMD_REG) != 0 {}
-        while (read_register(SPI_RD_STATUS_REG) & STATUS_WIP_BIT) != 0 {}
+        self.write_register(Self::SPI_RD_STATUS_REG, 0);
+        self.write_register(Self::SPI_CMD_REG, Self::SPI_FLASH_RDSR);
+        while self.read_register(Self::SPI_CMD_REG) != 0 {}
+        while (self.read_register(Self::SPI_RD_STATUS_REG) & Self::STATUS_WIP_BIT) != 0 {}
     }
 
-    fn spi_write_enable() {
-        write_register(SPI_CMD_REG, SPI_FLASH_WREN);
-        while read_register(SPI_CMD_REG) != 0 {}
+    fn spi_write_enable(&self) {
+        self.write_register(Self::SPI_CMD_REG, Self::SPI_FLASH_WREN);
+        while self.read_register(Self::SPI_CMD_REG) != 0 {}
     }
 
-    pub fn flash_erase_block(address: u32) {
-        // unsafe{ esp_rom_spiflash_erase_block(address / FLASH_BLOCK_SIZE) };
-        erase(address, true);
+    fn flash_erase_block(&self, address: u32) {
+        self.erase(address, true);
     }
 
-    pub fn flash_erase_sector(address: u32) {
-        erase(address, false);
+    fn flash_erase_sector(&self, address: u32) {
+        self.erase(address, false);
     }
 
-    pub fn erase_region(address: u32, size: u32) -> Result<(), Error> {
+    fn erase_region(&self, address: u32, size: u32) -> Result<(), Error> {
         if address % FLASH_SECTOR_SIZE != 0 {
-            return Err(Error::Err0x32);
+            return Err(Err0x32);
         } else if size % FLASH_SECTOR_SIZE != 0 {
-            return Err(Error::Err0x33);
-        } else if unsafe { esp_rom_spiflash_unlock() } != 0 {
-            return Err(Error::Err0x34);
+            return Err(Err0x33);
+        } else if self.unlock_flash().is_err() {
+            return Err(Err0x34);
         }
 
         let sector_start = address / FLASH_SECTOR_SIZE;
@@ -185,91 +207,108 @@ pub mod esp32c3 {
 
         for sector in sector_start..sector_end {
             if unsafe { esp_rom_spiflash_erase_sector(sector) } != 0 {
-                return Err(Error::Err0x35);
+                return Err(Err0x35);
             }
         }
 
         Ok(())
     }
 
-    pub fn spi_flash_read(address: u32, data: &mut [u8]) -> Result<(), Error> {
+    fn spi_flash_read(&self, address: u32, data: &mut [u8]) -> Result<(), Error> {
         let data_ptr = data.as_mut_ptr();
         let data_len = data.len() as u32;
 
         match unsafe { esp_rom_spiflash_read(address, data_ptr, data_len) } {
             0 => Ok(()),
-            _ => Err(Error::Err0x63),
+            _ => Err(Err0x63),
         }
     }
 
-    pub fn unlock_flash() -> Result<(), Error> {
-        if unsafe { esp_rom_spiflash_unlock() } != 0 {
-            Err(Error::FailedSpiUnlock)
-        } else {
-            Ok(())
+    fn unlock_flash(&self) -> Result<(), Error> {
+        let mut status: u32 = 0;
+        const STATUS_QIE_BIT: u32 = 1 << 9;
+        const SPI_WRSR_2B: u32 = 1 << 22;
+        const FLASHCHIP: *const RomSpiFlashChip = 0x3ffae270 as *const RomSpiFlashChip;
+
+        self.wait_for_ready();
+        if (unsafe { spi_read_status_high(&status) } != 0) {
+            return Err(FailedSpiUnlock);
         }
+
+        // Clear all bits except QIE, if it is set.
+        // (This is different from ROM SPIUnlock, which keeps all bits as-is.)
+        status &= STATUS_QIE_BIT;
+
+        self.spi_write_enable();
+        self.set_register_mask(Self::SPI_CTRL_REG, SPI_WRSR_2B);
+
+        if (unsafe { spi_write_status(FLASHCHIP, status) } != 0) {
+            return Err(FailedSpiUnlock);
+        }
+
+        Ok(())
     }
 
-    // ESP32S2_OR_LATER && !ESP32H2BETA2
-    pub fn get_security_info() -> Result<[u8; SECURITY_INFO_BYTES], Error> {
+    fn get_security_info(&self) -> Result<[u8; SECURITY_INFO_BYTES], Error> {
         let mut buf: [u8; SECURITY_INFO_BYTES] = [0; SECURITY_INFO_BYTES];
 
-        match unsafe { GetSecurityInfoProc(0, 0, buf.as_mut_ptr()) } {
+        match unsafe { get_security_info_proc(0, 0, buf.as_mut_ptr()) } {
             0 => Ok(buf),
-            _ => Err(Error::InvalidCommand), // Todo check ROM code for err val
+            _ => Err(InvalidCommand), // Todo check ROM code for err val
         }
     }
 
-    pub fn init() {
+    fn init(&self) {
         let mut spiconfig = unsafe { ets_efuse_get_spiconfig() };
 
-        let strapping = read_register(GPIO_STRAP_REG);
+        let strapping = self.read_register(Self::GPIO_STRAP_REG);
 
         if spiconfig == 0 && (strapping & 0x1c) == 0x08 {
             spiconfig = 1; // HSPI flash mode
         }
 
-        spi_attach(spiconfig);
+        self.spi_attach(spiconfig);
 
         let deafault_params = SpiParams {
             id: 0,
-            total_size: FLASH_MAX_SIZE,
+            total_size: Self::FLASH_MAX_SIZE,
             block_size: FLASH_BLOCK_SIZE,
             sector_size: FLASH_SECTOR_SIZE,
-            page_size: FLASH_PAGE_SIZE,
-            status_mask: FLASH_STATUS_MASK,
+            page_size: Self::FLASH_PAGE_SIZE,
+            status_mask: Self::FLASH_STATUS_MASK,
         };
 
-        let _ = spi_set_params(&deafault_params);
+        let _ = self.spi_set_params(&deafault_params);
     }
 
-    pub fn soft_reset() {
+    fn soft_reset(&self) {
         unsafe { software_reset() };
     }
 
-    pub fn delay_us(micro_seconds: u32) {
+    fn delay_us(&self, micro_seconds: u32) {
         unsafe { ets_delay_us(micro_seconds) };
     }
 
-    pub fn write_encrypted_enable() {
+    fn write_encrypted_enable(&self) {
         unsafe {
             esp_rom_spiflash_write_encrypted_enable();
         }
     }
-    pub fn write_encrypted_disable() {
+    fn write_encrypted_disable(&self) {
         unsafe {
             esp_rom_spiflash_write_encrypted_disable();
         }
     }
 
-    pub fn write_encrypted(addr: u32, data: *const u8, len: u32) -> Result<(), Error> {
+    fn write_encrypted(&self, addr: u32, data: *const u8, len: u32) -> Result<(), Error> {
         match unsafe { esp_rom_spiflash_write_encrypted(addr, data, len) } {
             0 => Ok(()),
-            _ => Err(Error::FailedSpiOp),
+            _ => Err(FailedSpiOp),
         }
     }
 
-    pub fn decompress(
+    fn decompress(
+        &self,
         r: *mut tinfl_decompressor,
         in_buf: *const u8,
         in_buf_size: *mut usize,
@@ -291,3 +330,40 @@ pub mod esp32c3 {
         }
     }
 }
+#[derive(Default)]
+pub struct Esp32c3;
+
+#[derive(Default)]
+pub struct Esp32;
+
+impl EspCommon for Esp32c3 {
+    // fn unlock_flash(&self, ) -> Result<(), Error> {
+    //     if unsafe{ esp_rom_spiflash_unlock() } != 0 {
+    //         Err(FailedSpiUnlock)
+    //     } else {
+    //         Ok(())
+    //     }
+    // }
+}
+
+impl EspCommon for Esp32 {
+    const SPI_BASE_REG: u32 = 0x3ff42000;
+    const SPI_RD_STATUS_REG: u32 = Self::SPI_BASE_REG + 0x10;
+    const SPI_EXT2_REG: u32 = Self::SPI_BASE_REG + 0xF8;
+    const SPI0_BASE_REG: u32 = 0x3ff43000;
+    const SPI0_EXT2_REG: u32 = Self::SPI0_BASE_REG + 0xF8;
+    const UART_BASE_REG: u32 = 0x3ff40000;
+    const GPIO_BASE_REG: u32 = 0x3ff44000;
+
+    fn get_security_info(&self) -> Result<[u8; SECURITY_INFO_BYTES], Error> {
+        Err(InvalidCommand)
+    }
+
+    fn flash_erase_block(&self, address: u32) {
+        unsafe { esp_rom_spiflash_erase_block(address / FLASH_BLOCK_SIZE) };
+    }
+
+    fn flash_erase_sector(&self, address: u32) {
+        unsafe { esp_rom_spiflash_erase_sector(address / FLASH_SECTOR_SIZE) };
+    }
+}
